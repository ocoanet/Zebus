<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#

var funcs = ParseFuncs(@"

    int nng_push0_open(NngSocket* s);
    int nng_pull0_open(NngSocket* s);
    int nng_close(NngSocket s);

	int nng_listen(NngSocket s, string url, NngListener* lp, int flags);
	int nng_dial(NngSocket s, string url, nng_dialer* dp, int flags);

	int nng_setopt_int(NngSocket s, string opt, int value);
	int nng_setopt_ms(NngSocket s, string opt, int ms);

	int nng_getopt_string(NngSocket s, string opt, byte** str);
	int nng_listener_getopt_string(NngListener l, string opt, byte** str);
	int nng_listener_close(NngListener l);

	int nng_send(NngSocket s, void* buf, IntPtr len, NngFlags flags);
	int nng_sendmsg(NngSocket s, IntPtr msg, NngFlags flags);

	int nng_recv(NngSocket s, void* data, IntPtr* size, NngFlags flags);
	int nng_recvmsg(NngSocket s, IntPtr* msgp, NngFlags flags);

	int nng_msg_alloc(IntPtr* msgp, IntPtr size);
	void* nng_msg_body(IntPtr msg);
	void nng_msg_free(IntPtr msg);
	IntPtr nng_msg_len(IntPtr msg);
	void nng_msg_clear(IntPtr msg);
	int nng_msg_append(IntPtr msg, void* val, IntPtr size);

	void nng_strfree(byte* str);
	void nng_free(void* ptr, IntPtr size);

    IntPtr nng_version();
    
").ToList();

var platforms = new[] {
    new PlatformDef("Win", "Abc.Zebus.libnng.dll"),
    new PlatformDef("Win32", "Abc.Zebus.libnng.x86.dll"),
    new PlatformDef("Win64", "Abc.Zebus.libnng.x64.dll"),
    new PlatformDef("Linux", "Abc.Zebus.libnng.so"),
    //new PlatformDef("Linux32", "Abc.Zebus.libnng.x86.so"),
    //new PlatformDef("Linux64", "Abc.Zebus.libnng.x64.so"),
};

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using System.Security;

namespace Abc.Zebus.Nng.Transport
{
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    unsafe partial class NngNative
    {
<# foreach (var func in funcs) { #>
        public static <#= func.Declaration #>
            => _impl.<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.Name)) #>);

<# } #>

        private abstract class LibImpl
        {
<# foreach (var func in funcs) { #>
            public abstract <#= func.Declaration #>;
<# } #>
        }

<# foreach (var platform in platforms) { #>
        [SuppressUnmanagedCodeSecurity]
        private class <#= platform.Name #>Impl : LibImpl
        {
<# foreach (var func in funcs) { #>
            public override <#= func.Declaration #>
                => extern_<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.Name)) #>);

            [DllImport("<#= platform.LibName #>", EntryPoint = "<#= func.Name #>", CallingConvention = CallingConvention.Cdecl)]
            private static extern <#= func.ReturnType #> extern_<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.GetPInvokeAttributes() + p.Declaration)) #>);

<# } #>
        }

<# } #>
    }
}
<#+

private IEnumerable<FuncDef> ParseFuncs(string funcs)
{
    var funcsRe = new Regex(
        @"
            \G \s*
            (?<returnType>\S+) \s+ (?<funcName>\w+) \s* \(
            (?<param> \s*
			    (?<paramMod>out\s)?
                (?<paramType>\S+) \s+ (?<paramName>\w+) \s*
                (?(?=,),|(?=\)))
            )*
            \) \s* ;
        ",
        RegexOptions.IgnorePatternWhitespace | RegexOptions.CultureInvariant
    );

    foreach (Match match in funcsRe.Matches(funcs))
    {
        var def = new FuncDef
        {
            ReturnType = match.Groups["returnType"].Value,
            Name = match.Groups["funcName"].Value
        };

        var paramTypes = match.Groups["paramType"].Captures.Cast<Capture>().Select(i => i.Value).ToList();
        var paramNames = match.Groups["paramName"].Captures.Cast<Capture>().Select(i => i.Value).ToList();

        for (var i = 0; i < paramNames.Count; ++i)
        {
            def.Parameters.Add(new FuncParamDef
            {
                Type = paramTypes[i],
                Name = paramNames[i]
            });
        }

        yield return def;
    }
}

private class FuncDef
{
    public string ReturnType;
    public string Name;
    public readonly List<FuncParamDef> Parameters = new List<FuncParamDef>();

    public string Declaration => $"{ReturnType} {Name}({ParametersDeclaration})";
    public string ParametersDeclaration => string.Join(", ", Parameters.Select(p => p.Declaration));
}

private class FuncParamDef
{
    public string Type;
    public string Name;
    public string Mod;

    public string Declaration => $"{Type} {Name}";

    public string GetPInvokeAttributes()
    {
        switch (Type)
        {
            case "string":
                return $"[In, MarshalAs(UnmanagedType.LPStr)] ";

            default:
                return string.Empty;
        }
    }
}

private class PlatformDef
{
    public readonly string Name;
    public readonly string LibName;

    public PlatformDef(string name, string libName)
    {
        Name = name;
        LibName = libName;
    }
}

#>
